package hr.fer.zemris.java.custom.collections;

import java.util.LinkedList;

public class LinkedListIndexedCollection extends Collection {

	private static class ListNode {
		ListNode previous;
		ListNode next;
		Object value;
	}

	private int size = 0;
	private ListNode first;
	private ListNode last;

	public static void main(String[] args) {
		LinkedListIndexedCollection kolekcija = new LinkedListIndexedCollection();
		kolekcija.add(1);
		kolekcija.add(2);
		kolekcija.add(3);
		kolekcija.add(4);
		kolekcija.add(5);
		System.out.println(kolekcija.first.value + " " + kolekcija.first.next.value + " "
				+ kolekcija.first.next.next.value);
	}

	protected LinkedListIndexedCollection() {
		this.first = null;
		this.last = null;
	}

	protected LinkedListIndexedCollection(Collection collection) {
		this();
		this.addAll(collection);
	}

	public int size() {
		return size;
	}

	public void add(Object value) {
		if (value == null) {
			throw new IllegalArgumentException();
		}
		ListNode novak = new ListNode();
		novak.value = value;
		if (size == 0) {
			first = last = novak;
		}
		else{
			last.next = novak;
			novak.previous = last;
			last = novak;
		}

	}

	public boolean contains(Object value) {
		if (indexOf(value) < 0)
			return false;
		return true;
	}

	private Object get(int index) {
		if (index < 0 || index > this.size) {
			throw new IndexOutOfBoundsException();
		}
		if (index > size / 2) {
			ListNode last = this.last;
			for (int j = this.size; j > index; j--) {
				last = last.previous;
			}
			return last.value;
		} else {
			ListNode first = this.first;
			for (int j = 0; j > index; j++) {
				first = first.next;
			}
			return first.value;
		}
	}

	public int indexOf(Object value) {
		ListNode current = this.first;
		for (int index = 0; current != null; index++, current = current.next) {
			if (current.equals(value)) {
				return index;
			}
		}
		return -1;
	}

	public boolean remove(Object value) {
		if (this.first.value == value)
			return true;
		else {
			ListNode current = this.first.next;
			while (current.next != null) {
				if (current.value == value) {
					current.previous.next = current.next;
					current.next.previous = current.previous;
					return true;
				}
			}
		}
		return false;
	}

}
