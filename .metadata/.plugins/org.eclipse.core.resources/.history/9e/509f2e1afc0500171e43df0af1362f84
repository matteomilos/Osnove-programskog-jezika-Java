package hr.fer.zemris.java.custom.collections;

import java.util.LinkedList;

public class LinkedListIndexedCollection extends Collection {

	private static class ListNode {
		ListNode previous;
		ListNode next;
		Object valueStorage;
	}

	private int size = 0;
	private ListNode first;
	private ListNode last;
	
	public static void main(String[] args) {
		LinkedListIndexedCollection kolekcija = new LinkedListIndexedCollection();
		kolekcija.add(1);
		kolekcija.add(2);
		kolekcija.add(3);
		kolekcija.add(4);
		kolekcija.add(5);
		for(int i=0; i<kolekcija.size; i++){
			System.out.println(kolekcija.get(i) + " ");
		}
	}

	private Object get(int index) {
		if(index <0 || index>this.size) {
			throw new IndexOutOfBoundsException();
		}
		if(index>size/2){
			ListNode last = this.last;
			for(int j = this.size; j>index;j-- ){
				last=last.previous;
			}
			return last.valueStorage;
		}
		else{
			ListNode first = this.first;
			for(int j = 0; j>index;j++ ){
				first=first.next;
			}
			return first.valueStorage;
		}
	}

	protected LinkedListIndexedCollection() {
		this.first = null;
		this.last = null;
	}

	protected LinkedListIndexedCollection(Collection collection) {
		this();
		this.addAll(collection);
	}

	public int size() {
		return size;
	}

	public void add(Object value) {
		if (value == null) {
			throw new IllegalArgumentException();
		}
		if(size == 0){
			this.first = new ListNode();
			this.first.valueStorage = value;
			this.last = new ListNode();
			this.last.valueStorage = value;
			first.next= last;
			last.previous = first;
			size++;
			return;
		}
		ListNode novak = new ListNode();
		novak.valueStorage = value;
		last.next = novak;
		novak.previous = last;
		novak.next = null;
		this.last = novak;
		this.size++;
	}

	public boolean contains(Object value) {
		if (indexOf(value) < 0)
			return false;
		return true;
	}

	public int indexOf(Object value) {
		ListNode current = this.first;
		for (int index = 0; current != null; index++, current = current.next) {
			if (current.equals(value)) {
				return index;
			}
		}
		return -1;
	}

	public boolean remove(Object value) {
		if(this.first.valueStorage==value) return true;
		else{
			ListNode current = this.first.next;
			while(current.next != null){
				if(current.valueStorage == value){
					current.previous.next = current.next;
					current.next.previous = current.previous;
					return true;
				}
			}
		}
		return false;
	}

}
